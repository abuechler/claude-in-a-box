#!/usr/bin/env zsh
###########################################################
# Claude In A Box - Command Line Launcher
#
# Basically launches Claude Code in a Docker container and mounts the project
# directory plus some settings. Unfortunately Claude Code doesn't store
# settings in a way that is easy to work with, there are several locations,
# from the container POV they are:
#
# - $HOME/.claude
# - $HOME/.claude/settings.json
# - $HOME/.claude.json
# - <project>/.claude/settings.json
# - <project>/.claude/settings.local.json
#
# Those inside the project directory are easy to handle, we can just add them
# to Git if we want to. The $HOME/.claude directory with the
# $HOME/.claude/settings.json is easy too, since the settings.json is simple
# and doesn't need to contain generated data, or even secrets.
#
# The tricky part is actually the $HOME/.claude.json file, if we just mount an
# empty file, claude code will refuse to start and report a corrupted settings
# file. Which it can fix by itself, but still it is ugly. Generating one is
# possible, but should we really? Let's see how brittle that is and generate
# one for now.
##########################################################
set -euo pipefail
version="1.0.3"

script_dir=$(dirname "$(realpath "$0")")

project_directory="$(pwd)"
# Derive the project name from the directory name, sanitized to safe characters
project_name="$(basename "$project_directory" | tr -cd 'A-Za-z0-9_-')"
# Contains files and settings for all projects
claude_project_settings_root="$HOME/.claude_project_settings"
# Project specific settings directory => All the stuff we want to persist per project across container runs
claude_project_settings="$claude_project_settings_root/$project_name"
# Claude settings directory for this project => Mounted to /home/node/.claude in the container
claude_project_dot_dir="$claude_project_settings/claude"
# Claude settings JSON file for this project => Mounted to /home/node/.claude.json in the container
claude_project_dot_json="$claude_project_settings/claude.json"
# Shell history file for this project, see Dockerfile => There's going to be intermediate files in this dir as well, that's why we put all of them in a separate dir.
claude_project_shell_history_dir="$claude_project_settings/shell_history"
claude_project_shell_history_file="$claude_project_shell_history_dir/.zsh_history"
# Generic Claude In A Box settings for all projects. If this folder contains an init.sh script that is executable, it will be run at container startup.
claude_in_a_box_global_settings="$HOME/.claude-in-a-box"
# GitHub token for this project, if it exists Git credentials will be generated.
gh_project_token_file="$claude_project_settings/.gh_token"

docker_image="claude-in-a-box"
# Image variant configuration
default_variant="java_quarkus"
image_variant=""
indent_for_echos="   "

# Safely parse a value from INI-style config file (no code execution)
# Usage: value=$(parse_ini_value "file" "key")
# Returns: 0 if key found, 1 if not found
parse_ini_value() {
  local file="$1" key="$2"
  local line k v
  [[ ! -f "$file" ]] && return 1
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ "$line" =~ ^[[:space:]]*\; ]] && continue
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    # Skip lines without =
    [[ "$line" != *"="* ]] && continue
    # Split on first =
    k="${line%%=*}"
    v="${line#*=}"
    # Trim whitespace from key
    k="${k#"${k%%[![:space:]]*}"}"
    k="${k%"${k##*[![:space:]]}"}"
    # Check if key matches
    if [[ "$k" == "$key" ]]; then
      # Trim whitespace from value
      v="${v#"${v%%[![:space:]]*}"}"
      v="${v%"${v##*[![:space:]]}"}"
      # Strip surrounding double quotes
      if [[ "$v" == \"*\" ]]; then
        v="${v#\"}"
        v="${v%\"}"
      # Strip surrounding single quotes
      elif [[ "$v" == \'*\' ]]; then
        v="${v#\'}"
        v="${v%\'}"
      fi
      echo "$v"
      return 0
    fi
  done < "$file"
  return 1
}

# Global arrays for variant discovery (avoids subshell issues)
declare -a discovered_variants_list=()
declare -A variant_platforms=()

# Discover available variants by scanning Dockerfile.* files
# Populates discovered_variants_list and variant_platforms global arrays
discover_variants() {
  local docker_dir="$script_dir/docker"
  local -A variants=()
  variant_platforms=()

  for dockerfile in "$docker_dir"/Dockerfile.*; do
    [[ -f "$dockerfile" ]] || continue
    local suffix="${$(basename "$dockerfile")#Dockerfile.}"

    # Handle platform-specific dockerfiles (e.g., flutter.amd64)
    if [[ "$suffix" == *.amd64 ]]; then
      local variant="${suffix%.amd64}"
      variant_platforms[$variant]="linux/amd64"
      variants[$variant]=1
    else
      variants[$suffix]=1
    fi
  done

  # Sorted unique keys from associative array
  discovered_variants_list=("${(@ok)variants}")
}

prompt_for_variant() {
  # Discover available variants (populates global discovered_variants_list)
  discover_variants

  local variant_count=${#discovered_variants_list[@]}

  echo ""
  echo "========================================"
  echo "  Claude In A Box - Image Variant Selection"
  echo "========================================"
  echo ""
  echo "Available variants:"
  echo ""

  local i=1
  local default_index=1
  for v in "${discovered_variants_list[@]}"; do
    if [[ "$v" == "$default_variant" ]]; then
      echo "  $i) $v (default)"
      default_index=$i
    else
      echo "  $i) $v"
    fi
    ((i++))
  done
  echo ""

  while true; do
    printf "Select variant [1-%d] (default: %d): " "$variant_count" "$default_index"
    read -r choice

    # Handle empty input (default)
    if [[ -z "$choice" ]]; then
      image_variant="$default_variant"
      break
    fi

    # Handle numeric input
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= variant_count )); then
      image_variant="${discovered_variants_list[$choice]}"
      break
    fi

    # Handle variant name input
    for v in "${discovered_variants_list[@]}"; do
      if [[ "$choice" == "$v" ]]; then
        image_variant="$v"
        break 2
      fi
    done

    echo "Invalid selection. Please enter 1-$variant_count or a variant name."
  done

  echo ""
  echo "Selected variant: $image_variant"

  # Save to config file
  if grep -q "^image_variant=" "$project_directory/.claude_in_a_box" 2>/dev/null; then
    # Update existing entry
    sed -i.bak "s/^image_variant=.*/image_variant=\"$image_variant\"/" "$project_directory/.claude_in_a_box"
    rm -f "$project_directory/.claude_in_a_box.bak"
  else
    # Append new entry
    echo "image_variant=\"$image_variant\"" >> "$project_directory/.claude_in_a_box"
  fi

  echo "Saved variant selection to .claude_in_a_box"
  echo ""
}

init_project_settings() {
  # We're assuming that claude-in-a-box should be started from the current directory, let's do some sanity checks.
  if [[ "$project_directory" == "$HOME" || "$project_directory" == "/" || ! -d "$project_directory/.git" ]]; then
    echo "âŒ Refusing to run in \$HOME, root or any directory that is not a Git project."
    exit 1
  fi

  echo "âš™ï¸ Checking project settings..."

  # Create project settings directory if it doesn't exist
  if [[ -d "$claude_project_dot_dir" ]]; then
    echo -e "${indent_for_echos}âœ… Found them in '$claude_project_dot_dir'."
    # Add settings file on existing projects if missing
    if [[ ! -f "$claude_project_dot_dir/settings.json" ]]; then
      cp "$script_dir/init_config/settings.json" "$claude_project_dot_dir"
    fi
  else
    echo -e "${indent_for_echos}ðŸ“ Creating project settings directory..."
    mkdir -p "$claude_project_dot_dir"
    cp "$script_dir/init_config/settings.json" "$claude_project_dot_dir"
    # Generate a unique userID (64 hex chars) using only default tools
    # available on macOS and Linux, see comments at the beginning of this script.
    user_id=$(od -An -N32 -tx1 /dev/urandom | tr -d ' \n')
    # Copy claude.json and update the userID field using sed
    sed "s/\"userID\": null/\"userID\": \"$user_id\"/" "$script_dir/init_config/claude.json" >"$claude_project_dot_json"
  fi

  mkdir -p "$claude_project_shell_history_dir"
  if [[ ! -f "$claude_project_shell_history_file" ]]; then
    touch "$claude_project_shell_history_file"
  fi

  # Determine which GitHub token to use
  if [[ -s "$gh_project_token_file" ]]; then
    gh_token_file="$gh_project_token_file"
    echo -e "${indent_for_echos}âœ… Using project-specific GitHub token for project '$project_name'."
  else
    echo -e "${indent_for_echos}â„¹ï¸ No GitHub token found. To use gh CLI, create a fine-grained token and save it to:"
    echo -e "${indent_for_echos}${indent_for_echos}ðŸ‘‰ $gh_project_token_file"
    # Create empty token file to prevent mount errors
    touch "$gh_project_token_file"
    chmod 600 "$gh_project_token_file"
    gh_token_file="$gh_project_token_file"
  fi

  if [[ ! -d "$claude_in_a_box_global_settings" ]]; then
    echo -e "${indent_for_echos}ðŸ“ Creating user settings directory in $claude_in_a_box_global_settings"
    mkdir -p "$claude_in_a_box_global_settings"
  fi

  if [[ ! -f .mcp.json ]]; then
    echo -e "${indent_for_echos}â„¹ï¸ No .mcp.json file found in project directory. Creating one with Playwright settings..."
    cp "$script_dir/init_config/mcp.json" "$project_directory/.mcp.json"
    echo -e "${indent_for_echos}ðŸ’¡You might want to add the $project_directory/.mcp.json file to Git and commit it."
  fi

  if [[ ! -f "$project_directory/.claude_in_a_box" ]]; then
    echo -e "${indent_for_echos}â„¹ï¸ No .claude_in_a_box file found in project directory. Creating one..."
    safe_project_name=$(echo "$project_name" | tr -cd 'A-Za-z0-9_-')
    echo "project_name=\"$safe_project_name\"" >"$project_directory/.claude_in_a_box"
    echo -e "${indent_for_echos}ðŸ’¡You might want to add the $project_directory/.claude_in_a_box file to Git and commit it."
  fi

  # Parse config values safely (no code execution, unlike 'source')
  local parsed_project_name
  if parsed_project_name=$(parse_ini_value "$project_directory/.claude_in_a_box" "project_name"); then
    # Sanitize: allow only alphanumeric, underscore, and hyphen
    project_name=$(echo "$parsed_project_name" | tr -cd 'A-Za-z0-9_-')
    if [[ "$parsed_project_name" != "$project_name" ]]; then
      echo -e "\tâš ï¸  Project name sanitized: '$parsed_project_name' â†’ '$project_name'"
    fi
  fi

  # Validate and prompt for image_variant if not set
  # Discover variants first to populate discovered_variants_list and variant_platforms
  if ! image_variant=$(parse_ini_value "$project_directory/.claude_in_a_box" "image_variant"); then
    image_variant=""
  fi
  discover_variants


  if [[ -z "${image_variant:-}" ]]; then
    echo -e "${indent_for_echos}â„¹ï¸  No image variant configured."
    prompt_for_variant
  elif [[ ! " ${discovered_variants_list[*]} " =~ \ ${image_variant}\  ]]; then
    echo -e "${indent_for_echos}âš ï¸  Invalid image_variant '$image_variant' in config."
    echo -e "${indent_for_echos}Valid options: ${discovered_variants_list[*]}"
    prompt_for_variant
  else
    echo -e "${indent_for_echos}âœ… Using image variant: $image_variant"
  fi

  # Check Docker is available
  echo "ðŸ³ Checking Docker..."
  if ! docker info &>/dev/null; then
    echo -e "${indent_for_echos}âŒ Docker is not installed or not running. Please install or start Docker."
    exit 1
  fi
  echo -e "${indent_for_echos}âœ… Docker is running."
}

build_docker_image() {
  local image_type="$1"      # "base" or variant name
  local platform="${2:-}"    # optional, auto-detected if not provided
  local tag dockerfile platform_args=() platform_suffix="" base_version="$version"

  # Only show header for variant builds (not recursive base builds)
  if [[ "$image_type" != "base" ]]; then
    echo "ðŸ³ Checking if Docker images have been built..."
  fi

  # Auto-detect platform for variants requiring cross-platform emulation
  if [[ -z "$platform" && "$image_type" != "base" ]]; then
    local host_arch
    host_arch="$(uname -m)"
    local required_platform="${variant_platforms[$image_type]:-}"
    if [[ -n "$required_platform" && ("$host_arch" == "arm64" || "$host_arch" == "aarch64") ]]; then
      echo -e "${indent_for_echos}ðŸŽ Apple Silicon detected - building $required_platform image (runs via Rosetta)"
      platform="$required_platform"
    fi
  fi

  # Handle platform
  if [[ -n "$platform" ]]; then
    platform_suffix="${platform#*/}"  # Extract "amd64" from "linux/amd64"
    platform_args=(--platform "$platform")
    base_version="$version-$platform_suffix"
  fi

  # Determine tag and dockerfile
  if [[ "$image_type" == "base" ]]; then
    tag="claude-in-a-box:base-${base_version}"
    dockerfile="Dockerfile.base"
  else
    tag="$docker_image:${image_type}-${base_version}"
    # Try platform-specific dockerfile first, fall back to generic
    if [[ -n "$platform_suffix" && -f "$script_dir/docker/Dockerfile.${image_type}.${platform_suffix}" ]]; then
      dockerfile="Dockerfile.${image_type}.${platform_suffix}"
    else
      dockerfile="Dockerfile.${image_type}"
    fi
  fi

  # Check if image already exists
  if docker image inspect "$tag" &>/dev/null; then
    echo -e "${indent_for_echos}âœ… Image '$tag' already exists."
    return 0
  fi

  # Build dependencies: parse FROM line to find parent image
  if [[ "$image_type" != "base" ]]; then
    local dockerfile_path="$script_dir/docker/$dockerfile"
    local from_line parent_variant
    from_line=$(grep -E "^FROM " "$dockerfile_path" | head -1)

    # Extract parent variant from FROM claude-in-a-box:<variant>-${VERSION}
    # Pattern matches: claude-in-a-box:<variant>- where variant is lowercase with underscores
    if [[ "$from_line" =~ 'claude-in-a-box:([a-z_]+)-' ]]; then
      parent_variant="${match[1]}"
      echo -e "${indent_for_echos}ðŸ“¦ Image depends on: $parent_variant"
      if [[ "$parent_variant" == "base" ]]; then
        build_docker_image "base" "$platform"
      else
        # Recursively build parent variant (which will build its dependencies)
        build_docker_image "$parent_variant" "$platform"
      fi
    fi
  fi

  echo -e "${indent_for_echos}ðŸ”§ Building Docker image '$tag'..."
  local current_timezone
  current_timezone="$(readlink /etc/localtime | sed 's|.*/zoneinfo/||')"

  local build_args=(--no-cache "${platform_args[@]}" --build-arg TZ="$current_timezone")

  # Variant images need VERSION arg to reference the correct base
  if [[ "$image_type" != "base" ]]; then
    build_args+=(--build-arg VERSION="$base_version")
  fi

  (
    cd "$script_dir/docker"
    docker build "${build_args[@]}" -t "$tag" -f "$dockerfile" .
  )
}

run_claude_code() {
  local variant_tag
  local platform_args=()
  local image_variant
  local tag_version="$version"
  image_variant=$(parse_ini_value "$project_directory/.claude_in_a_box" "image_variant")

  # Use matching platform for variants that require cross-platform emulation
  local host_arch
  host_arch="$(uname -m)"
  local required_platform="${variant_platforms[$image_variant]:-}"
  if [[ -n "$required_platform" && ("$host_arch" == "arm64" || "$host_arch" == "aarch64") ]]; then
    platform_args=(--platform "$required_platform")
    local platform_suffix="${required_platform#*/}"
    tag_version="$version-$platform_suffix"
  fi

  variant_tag="$docker_image:${image_variant}-${tag_version}"

  echo "ðŸš€ Running Claude In A Box ($image_variant image) for project '$project_name'..."
  docker run -ti --rm --name "claude-in-a-box-$project_name" \
    "${platform_args[@]}" \
    --entrypoint "/bin/zsh" \
    -v "$project_directory:/workspace" \
    -v "$gh_token_file:/home/node/.gh_token:ro" \
    -v "$claude_project_dot_dir:/home/node/.claude" \
    -v "$claude_project_dot_json:/home/node/.claude.json" \
    -v "$claude_project_shell_history_dir:/home/node/.shell_history" \
    -v "$claude_in_a_box_global_settings:/home/node/.claude-in-a-box:ro" \
    "$variant_tag"
}

###########################################################
# Main execution
###########################################################
init_project_settings
build_docker_image "$(parse_ini_value "$project_directory/.claude_in_a_box" "image_variant")"
run_claude_code
